
const float SDF_PI = 3.14159265358979323846264338327950288;
const float SDF_TAU = 3.14159265358979323846264338327950288 * 2.;

float stroke(float x, float s, float w) {
    float d = step(s, x+w*.5)
    - step(s,x-w*.5);
    return clamp(d, 0., 1.);
}

float circleSDF(vec2 st) {
    return length(st-.5)*2.;
}

float circleSDF2(vec2 st, float size) {
    return length(st) - size;
}

float fill(float x, float size) {
    return 1.-step(size, x);
}

float opOnion( in float sdf, in float thickness )
{
    return abs(sdf)-thickness;
}

float rectSDF(vec2 st, vec2 s) {
    st = st*2.-1.;
    return max(abs(st.x/s.x),
    abs(st.y/s.y));
}

// 14
float vessicaSDF(vec2 st, float w) {
    vec2 offset = vec2(w*.5, 0.);
    return max( circleSDF(st-offset),
                circleSDF(st+offset));
}

// 15
float triSDF(vec2 st) {
    st = (st*2.-1.)*2.;
    return max(abs(st.x) * 0.866025 + st.y*0.5, -st.y*0.5);
}

// 19
vec2 stRotate(vec2 st, float a) {
    st = mat2(cos(a),-sin(a),
              sin(a),cos(a))*(st-0.5);
    return st+0.5;
}

// 26 NOTE(tracy): Can the raspi handle ints?
float polySDF(vec2 st, float V) {
    st = st*2.-1.;
    float a = atan(st.x, st.y) + SDF_PI;
    float r = length(st);
    float v = SDF_TAU/floor(V);
    return cos(floor(0.5+a/v)*v-a)*r;
}

// 28
float starSDF(vec2 st, float V, float s) {
    st = st*4.-2.;
    float a = atan(st.y, st.x)/SDF_TAU;
    float seg = a * floor(V);
    a = ((floor(seg)+0.5)/floor(V) + 
        mix(s, -s, step(.5,fract(seg)))) * SDF_TAU;
    return abs(dot(vec2(cos(a),sin(a)), st));
}

// 30
float raysSDF(vec2 st, float N) {
    st -= 0.5;
    return fract(atan(st.y, st.x)/SDF_TAU*floor(N));
}

// 34
float heartSDF(vec2 st) {
    st -= vec2(0.5, 0.8);
    float r = length(st)*5.;
    st = normalize(st);
    return r - 
        ((st.y*pow(abs(st.x), 0.67))/
        (st.y+1.5)-(2.)*st.y+1.26);
}

// 35
vec3 bridgeSDF(vec3 c, float d, float s, float w) {
    c *= 1.-stroke(d,s,w*2.);
    return c + stroke(d,s,w);
}




float HexDist(vec2 p) {
    p = abs(p);
    float c = dot(p, normalize(vec2(1,1.73)));
    c = max(c, p.x);
    return c;
}

float sdUnevenCapsule( vec2 p, float r1, float r2, float h )
{
    p.x = abs(p.x);
    float b = (r1-r2)/h;
    float a = sqrt(1.0-b*b);
    float k = dot(p,vec2(-b,a));
    if( k < 0.0 ) return length(p) - r1;
    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;
    return dot(p, vec2(a,b) ) - r1;
}

float sdVesica(vec2 p, float r, float d)
{
    p = abs(p);
    float b = sqrt(r*r-d*d);
    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))
    : length(p-vec2(-d,0.0))-r;
}

float sdEquilateralTriangle( in vec2 p, in float r )
{
    const float k = sqrt(3.0);
    p.x = abs(p.x) - r;
    p.y = p.y + r/k;
    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;
    p.x -= clamp( p.x, -2.0*r, 0.0 );
    return -length(p)*sign(p.y);
}

float sdBox( in vec2 p, in vec2 b )
{
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

float shapeN(float shape_num, in vec2 p, in float r1, in float r2, in float h) {
    shape_num = floor(shape_num);
    if (shape_num == 0.)
        return sdUnevenCapsule(p, r1, r2, h);
    if (shape_num == 1.)
        return sdVesica(p, r1, h);
    if (shape_num == 2.)
        return sdEquilateralTriangle(p, r1);
    if (shape_num == 3.)
        return sdBox(p, vec2(r1, r2));

    return sdBox(p, vec2(r1, r2));
}

float sdHexagram( in vec2 p, in float r )
{
    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);
    p = abs(p);
    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;
    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;
    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);
    return length(p)*sign(p.y);
}


